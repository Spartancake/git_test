# Report
The aim of this report is to explain the architecture or our project, the techniques that we chose to use, and some difficulties encountered during this experience. 

The team was composed by Lucia Maninetti, Riccardo Marcato Perini and Ramon Piha. 

We decided to divide the workload in tasks, with each member being assigned one. Then he/she would explain the chosen implementation to other members at completion. 

## Architecture and structure
Our project relies on a main class, which in turns calls the method getData() from the class DataGetter. This method is responsible for downloading from the given URL, and then creating a new Json file with only the information required. Other classes were created in support of these operations, such as Activity and ImportantActivityInfo. 
The DataGetter also has a method inputNum() which returns, reading from a file, the number of objects that should be retrieved. 

After the generation of the Json files via the DataGetter class the program starts the analysis by calling the resultCalc method in the ListResult class, which after creating a list with all the Json files, sends it to the Calcs class using the jsoncalc method together with a map of the Region ID generated during the generation of the Activity Json files and passed through the SortReg that is explained below. 
The Calcs class is the class designed to analyse the various json files to generate a report about  
 - The number of times that an activity type appears in the files 
 - The list of ID numbers of the activities that have GPS track data 
 - Identify the region(s) that have most activities and those that have has less 
To do this, a for cycle was used to first read the data inside a given json file using the readTree method of the Jackson databind package and then putting the needed data inside of 2 lists and a map. 
The various lists and maps are then used in the methods SortType.sorter, SortGps.sorter, RegCalc.mostReg and RegCalc.leastReg. 
SortType.sorter function is to create a map in which the various types of activities are counted, to do this we created a set using a copy of the list of activities, doing so removes every duplicate entry, then using a for cycle it scans the original list for every entry in the set, counting every entry that corresponds and then returning the map that was generated.
SortGps.sorter was the least heavy of the methods, containing only a forEach cycle that checks for every key on the map if the value is true and if so it puts the key in a list that is returned at the end of the cycle. 
The SortReg while not called in the jsoncalc method is essential to the analysis since his function is to take the list of Region IDs and by using the same methods of SortType.sorter create a map with every Region ID as key and the number of appearances as value, this map then sorted in a descending order based on the value using the sort function of the Collections class and returned. 
The methods of the RegCalc class use the map generated by SortReg to generate a map that uses a String as key and a generic Object as value, the first entry being the String "numberofActivities" and the number of times the highest/lowest entry in the Region ID map. The second entry consists of the String "regionIds" and a list containing the Region IDs that have highest/lowest appearances this map is then returned. 
After the necessary data has been sorted, we create an OutputAnalysis object using the result of the various methods this object and, after setting up the ObjectWriter of the Jackson package it writes the content of the OutputAnalysis object in the Analysis.json file. 

Then, the Validator class aimed to check the correctness of this json file, using a json schema contained in the analysis.json file. 
## Programming techniques
Lucia had to implement deserialization of information found on the given site, and the validation of the analysis file by means of a Json Schema. 
She implemented the techniques learnt in the course, such as the use of a BufferedReader, a mapper and a connection for the retrieval of data. Then, she used the class Activity and all its support classes as a blueprint for constructing objects from this data. JsonSetters and JsonIgnoreProperties were both useful tools for this operation.

Ramon Piha implemented the testing classes, wrote the pom.xml, serialized the information retrieved from the API and finally created the activity files. 
To write the testing classes he used methods learnt in the testing classes such as assertEquals(), the pom contained all the plugins and dependencies the project needed, for the serialization he used the Jackson methods to serialize objects, and the activity files were written with a BufferedWriter in the different files created for each activity object. 

## Difficulties
Although we did our best to maintain communication within our group and to help each other in case we needed it, we did also encounter some difficulties. 

The greatest difficulty Ramon encountered was the testing of the project. There were many parts of the project which did not depend on the programmer itself but relied on the API. To test the project, he abstracted the testing so that the methods would work in any situation and not only specifically with the project’s collected data. 

The difficulties encountered by Riccardo, which oversaw the analysis of the data, were due mostly the inexperience with this kind of work, for example the greatest problem encountered by him was derived by an error during the generation of the Analysis.json file in which the problem was the German characters being formatted in a way that the readTree format couldn't recognize it and without the experience in formatting he struggled with finding the precise problem and the solution. 

Lucia, which was in charge of validating the json files, struggled with the correct implementation of the Validator class. There were errors related to files not being found and the logger, but once they were solved her biggest concern was about the files being found only if both located in the “result” folder. In order to keep the json files there and the schema ones in the “resources” folder, she had to rely on the use of the classLoader. 